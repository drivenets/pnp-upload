"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_commonjs_1 = require("@pnp/common-commonjs");
const node_sp_auth_1 = require("node-sp-auth");
const node_fetch_1 = require("node-fetch");
const node_sp_auth_config_1 = require("node-sp-auth-config");
const url_1 = require("url");
const https_1 = require("https");
global.Headers = node_fetch_1.Headers;
global.Request = node_fetch_1.Request;
global.Response = node_fetch_1.Response;
class NodeFetchClient {
    constructor(authData, siteUrl) {
        this.authData = authData;
        this.siteUrl = siteUrl;
        this.authSettings = null;
    }
    fetch(url, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.initAuthOptions();
            if (!common_commonjs_1.isUrlAbsolute(url)) {
                url = common_commonjs_1.combine(this.siteUrl, url);
            }
            if (!common_commonjs_1.isUrlAbsolute(url)) {
                throw new Error('You should provide siteUrl parameter for bootstrap method or via credentials parameter');
            }
            const authData = yield node_sp_auth_1.getAuth(url, this.authSettings);
            const headers = new node_fetch_1.Headers();
            this.mergeHeaders(headers, options.headers);
            this.mergeHeaders(headers, authData.headers);
            const host = (url_1.parse(url)).host;
            const isOnPrem = host.indexOf('.sharepoint.com') === -1 && host.indexOf('.sharepoint.cn') === -1;
            if (isOnPrem) {
                headers.set('accept', 'application/json;odata=verbose');
            }
            common_commonjs_1.assign(options, {
                headers: headers
            });
            common_commonjs_1.assign(options, authData.options);
            const isHttps = url_1.parse(url).protocol === 'https:';
            if (isHttps && !options.agent) {
                options.agent = new https_1.Agent({ rejectUnauthorized: false });
            }
            return node_fetch_1.default(url, options);
        });
    }
    initAuthOptions() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.authSettings != null) {
                return;
            }
            if (typeof this.authData === 'string') {
                const authConfig = new node_sp_auth_config_1.AuthConfig({
                    configPath: this.authData,
                    encryptPassword: true,
                    saveConfigOnDisk: true
                });
                yield this.initAuthOptionsFromAuthConfig(authConfig);
            }
            else if (this.authData instanceof node_sp_auth_config_1.AuthConfig) {
                yield this.initAuthOptionsFromAuthConfig(this.authData);
            }
            else {
                this.authSettings = this.authData;
            }
        });
    }
    initAuthOptionsFromAuthConfig(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const ctx = yield config.getContext();
            this.authSettings = ctx.authOptions;
            if (!this.siteUrl) {
                this.siteUrl = ctx.siteUrl;
            }
        });
    }
    mergeHeaders(target, source) {
        if (typeof source !== 'undefined' && source !== null) {
            const temp = new node_fetch_1.Request('', { headers: source });
            temp.headers.forEach((value, name) => {
                target.set(name, value);
            });
        }
    }
}
exports.default = NodeFetchClient;
//# sourceMappingURL=NodeFetchClient.js.map